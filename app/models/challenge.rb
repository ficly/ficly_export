require 'will_paginate'

class Challenge < ActiveRecord::Base
  #acts_as_taggable
  #acts_as_solr :fields => [:title,:body], :if => proc{|record| $SOLR_ENABLED}
  #acts_as_indexed :fields => [:title,:body]
  belongs_to :user
  has_many :challenge_submissions

  has_many :ratings,
    :as => :resource
  has_many :comments, -> { order("comments.id desc")},
    :as => :resource

  has_many :stories, -> { where(is_draft: false) },
    :through => :challenge_submissions

  belongs_to :winner,
    :class_name => "Story",
    :foreign_key => 'winner_id'

  has_many :taggings, :as => :taggable


  def self.paged_find_tagged_with(tags, args = {})
    if tags.blank?
      paginate args
    else
      options = find_options_for_find_tagged_with(tags, :match_all => true)
      options.merge!(args)
      # The default count query generated by paginate includes COUNT(DISTINCT Posts.*) which errors, at least on mysql
      # Below we override the default select statement used to perform the count so that it becomes COUNT(DISTINCT Posts.id)
      paginate(options.merge(:count => { :select => options[:select].gsub('*', 'id') }))
    end
  end

  def self.calculate_activity_rating
    page = 1
    while (page)
      stories = Challenge.paginate(:page => page)
      stories.each do |story|
        story.calculate_activity_rating
        story.save
      end
      page = stories.next_page
    end
  end

  def self.featured
    self.one_featured.first
  end

  def tags
    @tags ||= taggings.map do |tagging|
			if !tagging.tag.nil?
      	Story.clean_tag(tagging.tag.name)
			end
    end
  end

  def calculate_activity_rating
    events = self.recent_reputation_events
    rating = 0
    events.each do |event|
      if event.event_type == "entry"
        rating = rating+10 unless event.user_id == self.user_id
      elsif event.event_type == "comment"
        rating = rating+10 unless event.user_id == self.user_id
      elsif event.event_type == "rating"
        rating = rating+5 unless event.user_id == self.user_id
      elsif event.event_type == "view"
        rating = rating+1
      end
    end
    self.activity_rating = rating
	self.view_count = self.reputation_events.count(:conditions => {:event_type => "view"})
  end

	def short_url
		"http://c.ficly.com/#{self.id}"
	end

  def over?
    self.ends_at < Time.now
  end

  def started?
    self.starts_at <= Time.now
  end

  def to_html
    r = RedCloth.new(self.body)
    r.sanitize_html = true
    return r.to_html
  end

  def hugo_json
    out = {
      id: id,
      description: self.to_html,
      date: self.created_at,
      title: self.title,
      user: {},
      stories: [],
      comments: [],
      winner: nil,
      type: "challenge"
    }

    if self.user
      out[:user] = self.user.for_association
    end

    if self.winner
      out[:winner] = self.winner.for_association
    end

    self.stories.published.includes(:user).each do |s|
      out[:stories] << s.for_association
    end

    self.comments.includes(:user).each do |comment|
      out[:comments] << comment.for_association
    end

    out
  end

  def hugo_export
<<-eos
#{JSON.pretty_generate(hugo_json)}

#{PandocRuby.convert(self.body, from: :textile, to: :markdown)}
eos
  end

  def self.hugo_export
    challenge_dir = "#{Rails.root}/tmp/hugo/challenge"
    FileUtils.mkdir_p(challenge_dir)

    Challenge.find_each do |c|
      puts "Writing: #{c.id}"
      FileUtils.mkdir_p("#{challenge_dir}/#{c.id}")
      f = File.open("#{challenge_dir}/#{c.id}/index.md","w+")
      f.puts c.hugo_export
      f.close
    end
  end

  protected
    def before_validation
      sanitizer = HTML::FullSanitizer.new
      self.body = sanitizer.sanitize(self.body)
      self.title = sanitizer.sanitize(self.title)
    end
    def after_create
      unless user.nil?
        self.reputation_events.create(
          :user => user,
          :event_type => "challenge_create"
        )
      end
    end

end
